# 第八章 指针

[TOC]

## 8.1 地址和指针

**变量**或者程序代码被存储在以字节为单位的存储器中

如果定义了一个变量，编译时会根据该变量的类型给它分配相应大小的内存单元

计算机为了对内存单元中的数据进行操作，一般是按**地址**存取的，也就是对内存单元进行了**标识编号**

变量地址：一般以变量所在内存单元第1个字节的地址作为变量的地址

直接访问：如`printf("% d",x)` 是`printf()`函数将变量`x`所在的内存地址为`1001-1002` 单元的内容按照**整型**格式输出，这种使用变量的方式就是`直接访问`

注意：区分**内存单元的内容**和**内存单元的地址**



指针访问：用指针`(point)`访问内存和操纵地址

例如：有一个变量`p`，存储了变量`x`的地址，通过变量`p`存储的地址信息，**间接访问**变量`x`

指针变量：专门用于存放地址变量的变量，简称为**指针**

如果一个指针的值是另一个变量的地址，则称该**指针变量指向那个变量**

**地址运算符**：`&`，`&n`表示变量`n`的内存地址或存储位置；其为一元运算符，与其他一元运算符有相同的优先级，结合方向为**右结合**

### 指针变量的定义

定义：如果在程序中声明一个变量，并使用地址作为该变量的值，那么这个变量就是指针变量

一般形式：`ElymeType *variable` ,`ElymeType`是 指针变量 所指向变量的类型，必须是有效的数据类型；`variable`是 指针变量 的名称

指针声明符：`*` 定义指针变量时使用  `int *p;` ，说明定义的变量时**指针变量**

指针值：可以是特殊的地址`0`，也可以是一个代表**机器地址**的正整数

指针与指针变量：**指针**是一个概念，是计算机内存地址的代名词之一；**指针变量**本身就是变量，特殊之处仅仅是它存放的是其他变量的**地址**，大多数情况下，二者都指**指针变量**

指针声明符`*`说明该变量是一个指针，`ElymeType`确定指向的对象占有的内存大小

定义多个指针变量时，每个变量前都需要指针声明符：`int *p1, *p2` 

**注意：** 指针变量的类型不是指 指针变量 本身的类型，而是指它所指向的变量的数据类型。无论何种类型的指针变量，他们都是用来存放地址的，因此不同类型指针变量**自身所占的内存空间大小都相同**

先赋值后使用：指针变量定义后，必须和一个特定变量**关联**后才可以使用它

空指针：特殊值`0`或者`NULL`赋值给指针时，为空指针，空指针不指向任何内存单元

一般不将**绝对地址**赋给指针，`NULL`除外

```c
int i, *p;	//define a point p

p = &i;		//指针p存放变量i的地址，指针p指向变量i
p = 0;
p = NULL;
p = (int *) 1732;	//强制类型转换避免 编译错误
```

定义指针变量时需要注意：

-   指针变量名 与普通变量名一样要是合法的C语言标识符
-   指针变量的类型被确定后， 只能指向同类型的变量
-   **指针声明符：**`*`并不是指针的组成部分，`int *p`表示`p`是指针变量，而不是`*p` 
-   指针变量命名时，可以用其类型首字母作为变量名首字母，提高程序可读性  `float *fp, *fptr, *f_ptr` 看到变量名可以联想到指向变量的类型

### 指针的基本运算

因为指针的值是其所指向变量的地址，通过指针就能间接访问那个变量，这些操作由**取地址符**`&`和**间接访问运算符**`*`完成

相同类型的指针可以进行**赋值、比较、算数**运算

#### 取地址运算和间接访问运算

取地址运算符：`&`  用去提取变量的地址，下面代码表示提取变量`a`的地址并赋给指针`p`，使指针`p`指向变量`a` 

```c
int *p, a = 3;
p = &a;
```

间接访问运算符：`*` ，该符号除用于 **指针变量声明** 外，还被用于访问指针所指向的变量。上述代码执行后，`*p`和`a`访问同一个内存单元，`*p`的值就是变量`a`的值

`*`初级运算：

-   `*p+1` ` ++*p` `(*p)++` 都表示`p`指向的变量`a`的值 `+1`
-   `*p++` `*(p++)` 是先取变量 `*p` 的值作为表达式的值，再将指针`p`的值`+1`，此时，`p`不再指向`a`  
-   `*`和`++`作为单目运算符，都是右结合，有相同的运算优先级，因此`*p++`会先算`p++`，此时`p`的值`+1`，而表达式`p++`的值按照`n++`运算规则，仍是`p`的值，即 `*p++`可以理解为`*q`，`q=p++`，`q`的值是原来`p`的值，所以`*p++ = a`仍然成立

#### 赋值运算

指针变量在被定义并进行**初始化赋值**以后，就可以和其他变量一样进行赋值运算

```c
int a = 3, *p1, *p2;
p1 = &a;
p2 = p1;
```

先将变量`a`的地址赋给变量`p1`，再将`p1`的值赋给`p2`，因此指针`p1`和`p2`都指向变量`a`

此时，`*p1` `*p2` `a`访问同一个内存单元，他们的值一样

给指针初始化赋值是使指针和所指向变量之间建立**关联**的必要过程

指针之间的相互赋值只能在**同类型**的指针之间进行

指针只有被赋值以后才能被正确使用

### 指针变量的初始化

C语言的变量在引用前必须先**定义并赋值**，指针变量在定义以后也要先赋值再引用

指针初始化时需要注意：

-   指针变量定义或者初始化时变量名前面的`*`是**指针声明符**，用于说明该变量时指针
-   提取变量地址并赋给指针时，该变量必须已经被定义，因为只有定义后系统才会分配存储单元，它的地址才能赋给指针变量
-   可以用初始化了的指针变量给另一个指针变量作初始化值
-   不能用数值作为指针变量的初值，但可以将指针变量初始化为一个**空指针**  `int *p = NULL` 
-   如果指针没有被赋初值，会指向一个不确定的单元，可能出现难以预料的结果

## 8.2 指针作为函数参数

C语言中函数参数包括**实参**和**形参** (或者可以称为**变量**和**参数**)

函数参数可以是`int` `char` `float`，也可使是`指针` 

**指针**作函数**参数**（形参）时，**变量的地址/指向该变量的指针**就是相应的**变量**值（实参）

值传递 规则：C语言中实参和形参之间的数据传递是单向的，调用函数不会改变实参（变量）的值，指针作为形参时也是一样

**引用调用`Call by Reference`：** 调用函数不能改变实参指针变量的值，但可以改变 **指针变量** 所指向的 变量的值。这种机制称为 引用调用，函数调用时把 **变量的地址** 作为实参

```c
void swap (int *px, int *py)//指针px,py分别指向变量a,b
{
  int t;
  t = *px;		//因为*px = a
  *px = *py;	//这种赋值操作时直接改变存储单元的内容，无需函数传递
  *py = t;
}
```

通过指针在函数调用时对变量存储单元的修改，可以达到一个函数返回多个目标值的目的，弥补`return`语句只能有一个返回值的缺陷

## 8.3 指针与数组（冒泡排序）

-   相同之处：**指针名**和**数组名**都代表内存地址
-   不同之处：**指针名**是一个变量，**数组名**是一个常量
-   关系：类似于同类型的**变量**和**常量**之间的关系

### 指针、数组、地址

定义数组时，编译器必须分配**基地址**和足够的**存储空间**，以存储数组的所有元素

基地址：数组的**基地址**是在内存中存储数组的起始位置，它是数组中第一个元素`a[0]`的地址，因此**数组名本身是一个地址**，即指针值

访问内存：指针和数组几乎相同，微妙且重要的区别是，指针是以地址作为值的变量，而数组名的值是一个特殊的**固定地址**，可以看做**常量指针** 

```c
int a[100], *p;		//a[0]的地址，就是数组a的基地址，也是数组名的值

p = a;				//此两句等价
p = &a[0];			//都是把数组a的基地址赋给指针p

p = a+1;			//此两句也等价
p = a[1];			//都把a[1]的地址赋给了指针p
```

上述代码中，`p = a+1`是合法的，而`a = a+1`是非法的，前者是变量，可以随时合法赋值，后者是常量，不能进行赋值操作

可以用指针对数组元素进行求和，循环中`p`的初值取数组`a`的基地址，然后连续取值 `&a[1]` `&a[2]` `...` `&a[n-1]` 

```c
sum = 0;
for(p = a;p <= a[99];p++)
  	sum += *p;
```

一般而言，假设`i`是`int`型变量，那么`p+i`就是距地址`p`的第`i`个偏移，`a+i`是距数组`a`的基地址的第`i`个偏移

`*(a+i)`与`a[i]`等价，下面是求和的第二种方法

```c
sum = 0;
for(i = 0; i < 100;i++)
  	sum += *(a+i);
```

表达式`*(p+i)`与`p[i]`等价，下面是求和的第三种方法

```c
p = a;
sum = 0;
for(i = 0;i < 100;i++)
  	sum += p[i];
```

由此可见：数组名可以使用**指针形式**，指针变量也可以转化为**数组形式**

本质不同：再次强调，数组是指针常量，`a=p` `a++` `a+=2`等改变数组名值得表达式都是非法的

#### 指针的算数运算

如果变量`p`是指向某个指定类型变量的指针，那么表达式`p+1`代表访问该类型的**下一个变量的内存地址**，即指针变量的算数运算是以 **该类型的一个存储单元 **为单位的

同类型指针相减：如果`p`和`q`都是指向数组的指针变量，`p-q`会产生一个`int`型的值，该值表示在`p`和`q`之间的元素的个数

指针的算数运算并非是指针的值直接与整数运算，而是变化整数个存储单元，存储单元的大小根据指针的类型确定，即`p+i`，表示从`p`指向的地址开始往后**偏移**`i`个存储单元，`p`的值变化`i`乘上数据类型的`byte`数

例如：`int a[10], *p;` `p = &a[1];`，假设`int`型为`4 Byte` ，`a[1]`的地址为`2004`，则`p--`后，`p`的值变为`2000`，减少了`4 Byte` ，也就是减少了一个`int`型存储单元，此时`p`指向`a[0]` 

指针的算数运算只包括**两个相同类型的指针相减** 以及 **指针加上或减去一个整数** 

#### 指针的比较运算

两个**相同类型**的指针可以使用**关系运算符**比较大小，比较的内容就是指针的值，即存储地址



**总的来说**，使用数组和指针可以实现相同的操作，但是指针**效率高，更灵活**。实际上在C编译器中，对数组的操作时自动转换为指针进行的，但与数组操作相比，指针操作的程序代码阅读上**不够直观** 

### 数组名作为函数的参数

函数定义时，数组的形参`a`是一个指针时，进行函数传递时，主函数**传递**的是数组`a`的**基地址**，**数组元素本身不被复制**

作为一种表示习惯，编译器允许在作为函数声明的**指针**中使用**数组方括号`[]`** ，此时`int a[]`等价于`int *a`

```c
int sum (int a[],int n)
  {
    int i, s = 0;
  	for (i = 0;i < n;i++)
      	s += a[i];
  	return s;
  }
```

调用函数`sum()` 对`b`中元素作累加：

`sum(*a,n)`中`*a`是起始地址，`n`为累加的个数，以下表最后一行为例， `sum(b+7,2*k)`把`b`的地址偏移`+7`，即从元素`b[7]`开始，在函数`sum()`中把指针变量`a`初始化为这个地址，这使得在函数调用中**所有地址计算结果都被相应地偏移**

| 调用               | 被计算和被返还的内容               |
| ---------------- | ------------------------ |
| `sum(b,100)`     | `b[0]+b[1]+...+b[99]`    |
| `sum(b,88)`      | `b[0]+b[1]+...+b[87]`    |
| `sum(&b[7],k-7)` | `b[7]+b[8]+...+b[k-1]`   |
| `sum(b+7,2*k)`   | `b[7]+b[8]+...+b[2*k+6]` |

### 冒泡排序

对于搜索大型数据库来说，对数据进行**排序`sort`**的算法是至关重要的

冒泡排序

-   之所以叫冒泡排序，是因为在进行从小到大排序时，小的数经过交换会慢慢从地下**冒**出来
-   算法效率：冒泡排序的效率并不高，这是因为它需要约$n^2/2$ 次比较，然而对一些小数组来说，它的性能还是可以接受的

```c
/*冒泡排序*/
void bubble (int a[], int n)
{
    int i, j, t;
    for ( i = 1; i < n; i++)            //外层循环
        for ( j = 0; j < n - i; j++)    //内层循环
            if (a[j] > a[j+1]){         //比较大小
                t = a[j];
                a[j] = a[j+1];
                a[j+1] = t;
            }
}
```

-   外层循环：用于依次找到最大的数。`i` 只是计数功能，不是下标，( 确定n个数的大小关系，只需要找到前n-1大的数即可。也就是冒泡排序`a[n]`时，外层循环`n-1`次 )
-   内层循环：通过遍历未排序部分，依次比较相邻元素，保证**前小后大**，即将未排序部分的最大元素通过一步步与相邻元素交换，将其移至未排序部分的最后

```c
/*选择排序*/
void choose (int a[], int n)
{
  	int i, k, temp;
  	int index;					//用于记录最小值下标
  
    for(i = 0;i < n-1;i++){		//外层循环
        index = i;
        for(k = i+1;k < n;k++)	//内层循环
            if(a[k] < a[index])
                index = k;
        temp = a[index];        //交换a[i]和a[index]
        a[index] = a[i];
        a[i] = temp;
    }
}
```

-   外层循环：依次找到未排序部分的最小值，并把最小值与未排序部分的第一个元素交换，其它位置元素不变
-   内层循环：找到未排序部分最小值的下标



##  8.4 字符串

字符串`string`：是一种特殊的`char`型一维数组

可以把字符串中的字符作为数组中的元素访问，或利用`char`型指针对其访问，这种灵活性使得在用C语言编写**字符串处理程序**时特别有用

### 字符串和字符指针

字符串常量：由一对双引号括起来的字符序列

-   存储：在内存中的**存放位置**由系统自动安排，通常被看作一个特殊的一维字符数组，与数组的存储类似。字符串常量中的所有字符在内存中**连续存放**
-   系统在存储一个字符串常量时，先给定一个起始地址，从该地址指定的存储单元开始，连续存放该**字符串**中的字符
-   字符串常量的值：字符串常量首字符的存储单元的地址，即字符串常量的起始地址
-   字符串常量实质上是指向该字符串首字符的**指针常量**

字符指针：

若定义一个字符指针接受字符串常量的值，该指针就指向字符串的首字符。这样**字符数组**和**字符指针**都可以用来处理字符串

```c
char sa [] = "array";
char *sp = "point";

printf("%s",sa);		//数组名sa作为printf的输出参数
printf("%s",sp);		//字符指针sp作为printf的输出参数
printf("%s","string");	//字符串常量作为printf的输出参数
//输出为
array point string
```

调用`printf()`函数，以`%s`控制输出格式为字符串，作为参数的**数组名`sa`**或**字符指针`sp`**、**字符串`string`**的值都是地址。输出参数给出**起始位置**（初始地址）， `'\0'`控制结束。无需循环输出每一个单个字符

与普通数组和指针的关系类似：

```c
printf("%s",sa+2);
printf("%s",sp+3);
printf("%s","string"+1);
//输出为
ray nt tring
```

牢牢把握输入参数为**起始地址**，而到`'\0'`结束 

字符数组与字符指针都可以处理字符串，但两者之间有重要区别：

```c
char sa[] = "This is a string";
char *sp = "This is a string";
```

存储 区别：

-   字符数组`sa` ：在内存中占用了**一块连续的单元**，有确定的地址，每个数组元素存放字符串的字符，字符串就存放在数组中
-   字符指针`sp` ：只占用一个可以存放地址的内存单元，存储字符串首字符的地址，而不是把字符串放到字符指针变量中去

改变内容 区别：

-   字符数组`sa` ：只能通过改变数组元素的内容来改变`sa`代表的字符串
-   字符指针`sp` ：直接改变字符指针的值，使它指向新的字符串

```c
strcpy (sa, "Hello");
sp = "Hello";
```

-   `sa = "Hello"`是非法的，因为`sa`是一个常量，不能被赋值

**为尽量避免引用未赋值指针所造成危害，在定义指针时，可以先将其初值设为空 `char *s = NULL` 

### 常用的字符串处理函数

标准库中含有很多**字符串**处理函数，它们都要求以字符串作为参数

#### 字符串的输入和输出

-   `scanf(格式控制字符串,输入参数表)` 
    -   格式控制字符串中使用格式控制字符`%s`
    -   输入参数**必须是**字符型数组名
    -   该函数遇**回车**或者**空格输入结束，并自动将输入的数据和字符串结束符 `'\0'` 存入数组中

```c
scanf("%s",s);		//假设s是字符型数组名
scanf_s("%s",s,n);	//为防止字符串越界，VS中使用scanf_s()函数，后面需要紧跟一个字符长度的参数n，表示最多输入n个字符
```

-   `printf(格式控制字符串,输出参数表)` 
    -   格式控制字符中使用格式控制字符`%s` 
    -   输出参数可以是**字符型数组名**或**字符串常量**
-   字符串输入函数`gets(s)` 
    -   参数`s`是字符数组名，函数从输入得到一个字符串
    -   遇**回车**输入结束，自动将输入的数据和`'\0'`送入数组
    -   采用`gets()`输入的字符串允许带空格
    -   返回值问题：`gets()`函数有返回值，如果输入成功，则返回字符串第一个字符的地址，如果失败则返回`NULL` ，但一般情况下`gets()`是为了输入字符串，不关心它的返回值
-   字符串输出函数`puts(s)`
    -   参数`s`可以是**字符数组名**或者字**符串常量**
    -   输出遇到`'\0'`自动将其转化为`'\n'`，即输出字符串后换行
    -   `puts()`也有返回值，如果成功执行了输出字符串的操作，则返回换行符号 `'\n'` ，否则返回`EOF`

#### 字符串的复制、连接和比较

-   字符串复制函数`char *strcpy (char *s1, char *s2)` 
    -   该字符串把字符串`s2`复制到`s1` ，直到遇到`s2` 中的`'\0'`为止
    -   `s1`要有足够的空间容纳`s2` ，且`s1`中的内容被覆盖，函数返回的是`s1` 
    -   简化表达为：`strcpy (s1,s2);` 
    -   `s1`必须是字符型数组 基地址，`s2`可以是字符数组名或字符串常量

```c
char s1[80], s2[80], form[80] = "Happy";
strcpy(s1,form);
strcpy(s2,"key");
```

-   字符串连接函数`strcat(s1,s2)` 
    -   `s1`参数必须是字符数组基地址
    -   参数`s2` 可以是字符数组名或字符串常量
    -   该函数将字符串`s2`接到字符串`s1`的后面，此时，原来`s1`的结束符`'\0'`被放在连接后的结束位置上
    -   数组`s1`的长度要足够存放连接后的字符串
    -   C语言不允许使用**算数运算**`+`将字符数组直接连接，即`str1=str1+t`是非法的
    -   除了调用`strcat()` ，还可以 逐个元素赋值

```c
char str1 [80] = "hello ",str2[80], t[80] = "world";
strcat(str1, t);
strcpy(str2, str1);
strcat(str2,"!");
//运算结果分别为
str1 == "hello world"
str2 == "hello world"
str2 == "hello world!"
```

-   字符串比较函数`strcmp(s1,s2)`
    -   参数`s1`,`s2` 可以是**字符数组名**或**字符串常量**
    -   返回：`strcmp()`返回一个整数，相等时返回`0` ，`s1`大于`s2`时返回一个正数，小于时返回一个负数
    -   直接比较：`str1 == str2,str1 < str2,str1 > str2` 比较的是两个字符串的起始地址，因为字符数组名的值就是该字符数组的基地址
    -   函数`strcmp()`比较的是两个字符串的内容
    -   比较规则：从两个字符串的首字符开始，一次比较相对应的字符（比较字符的ASCLL码值），知道出现不同的字符或遇到`'\0'` 为止。都相同返回`0`，否则，以第一个不相同的字符的比较结果为准，返回这两个字符的差，第一个字符串中对应字符的ASCLL码减去第二个字符串中对应字符的ASCLL码
-   字符串长度函数`strlen(s1)`
    -   参数`s1`可以是**字符数组名**或**字符串常量**
    -   返回：字符串的有效字符数，即`'\0'`之前的字符个数

**要给字符串分配足够大的空间，字符串越界是一个常见的编程错误**

## 8.5 用指针实现内存动态分配

变量在使用前必须被定义且安排好存储空间（包括**内存起始地址**和**存储单元大小**） 

C语言中 **全局变量**、**静态局部变量**的存储是在编译时确定的，其存储空间的实际分配在程序开始执行前完成。**局部自动变量** 是在执行进入变量定义所在的复合语句时为它们分配存储单元，这种变量的大小也是静态确定的

**静态存储：** 

-   优点：以静态方式安排存储的好处主要是实现比较方便、效率高，程序执行过程中需要做的事情比较简单
-   限制：对于无法确定大小的存储要求，只能通过定义一个足够大的存储空间，造成浪费，非常限制

**动态存储**

-   程序运行中的很多存储要求在写程序时无法确定，因此需要一种机制，可以根据运行时的实际存储需求 **分配适当的存储区**，用于存放那些在运行中才能确定数量的数据
-   动态存储管理机制，允许程序动态申请和释放存储空间

C语言主要有两种使用内存方法：一种是由编译系统分配的内存区，另一种是用内存动态分配方式，留给程序动态分配的存储区

动态存储区在用户的程序之外，不是由编译系统分配的，而是由用户在程序中通过**动态分配**获取的，使用动态分配能有效地使用内存

同一段内存可以被多次使用，使用时申请，用完就释放

### 动态内存分配步骤

1.  了解需要多少内存空间
2.  利用C语言提供的动态分配函数来分配所需要的存储空间
3.  使 指针 指向所获得的内存空间，以便用指针在该空间实施运算或操作
4.  当使用完毕内存后，释放这一空间

### 动态内存分配函数 `malloc()`

进行动态内存分配的操作，`stdio.h`提供了一组标准函数

-   动态内存分配函数`malloc()`    `malloc()  memory allocate` 
    -   函数原型：`void *malloc (unsigned size)` 
    -   功能：在内存的动态存储区中分配一连续空间，其长度为`size` 
    -   申请成功，则返回指向所分配内存空间的起始地址的指针；若不成功，则返回 `NULL` 
    -   返回类型：`(void *)` ，在具体使用中，将`malloc()` 的返回值转换为特定指针类型，赋给一个指针。这是通用指针的一个重要用途

```c
/*动态分配n个整数类型大小的空间*/
if ((p = (int *) malloc (n*sizeof(int))) == NULL)
{
  	printf("Not able to allocate memory.\n");
  	exit(1)
}
```

调用`malloc()` 时，应该利用`sizeof()`计算存储块大小，不要直接写数值，因为不同平台数据类型占用空间大小可能不同

每次动态分配都必须检查是否成功

**注意**：存储块是动态分配的，但它的大小在分配后也是确定的，不能越界使用，尤其不能越界赋值

### 计数动态存储分配函数`calloc()`

-   `count allocate` 
-   函数原型：`void *calloc (unsigned n,unsigned size)`
-   功能：在内存的动态存储区中分配`n`个连续空间，每一存储空间的长度为`size` ，并且分配后还把存储块里**全部初始化**为`0` 
-   若申请成功，则返回一个指向被分配内存空间的起始地址的指针；若不成功，则返回`NULL`
-   `malloc()`对分配的存储块不做任何事情，`calloc()` 对整个区域进行初始化

### 动态存储释放函数 `free()`

-   函数原型：`void free (void *ptr)`
-   功能：释放由动态存储分配函数申请到的整块内存空间，`ptr`为指向 要释放空间 的首地址
-   如果`ptr`的值是空指针，则`free()`什么都不做，该函数无返回值
-   在动态分配的存储块不再用时，就应及时将它释放，释放后不能再用指针去访问

### 分配调整函数 `realloc()`

-   函数原型：`void *realloc (void *ptr, unsigned size)`
-   功能：更改以前的存储分配
-   `ptr`必须是以前通过动态存储分配得到的**指针**
-   `size`为现在需要的空间大小
-   若分配失败，返回`NULL` ，同时原来`ptr`指向存储快的内容不变
-   若成功，返回一片能存放大小为`size`的区块，并保证该块的内容与原块的一致
-   如果`size`小于原块的大小，则内容为原块前`size`大小范围内的数据；如果新块更大，则原有数据存在新块的**前一部分**
-   如果分配成功，原存储块的内容就可能改变了，因此不允许再通过`ptr`去使用它

